
1 장은 `앨리스` 와 `밥` 이라는 인물이 소프트웨어 생산성을 도표로 나타내고 현실적으로 프로그래머의 생산성이 10배 이상일 수 있는지에 대한 연구를 하며 나눈 대화를 바탕으로 작성되었다.

이들의 대화를 읽으면서 느낀점을 정리하였다. 따라서 이 글은 책의 내용과 다를 수 있다.

## 생산성이란
본격적으로 정리하기전에 먼저 생산성은 어떤것인지 한번 알아보자.

1장을 읽다보면 생산성을 나타내는 기준에 대해 이야기 하는데 이렇게 표현한다.

> 생산성은 노력대비 가치이다.

풀어서 생각해보면 가치를 만들어냄에 있어 투자한 노력을 생산성이라 표현하게 되며 생산성과 노력은 반비례 관계에 있다고 할 수 있다. 즉, `생산성`, `노력`, `가치` 는 아래처럼 표기할 수도 있을 것 같다.

> 생산성 = 가치 / 노력

## 시간은 생산성의 기준이 될 수 없다

여기서 이런 의문이 들 수 있다. 

> 1. 생산성은 왜 노력에 반비례 하는 것인가?
> 2. 노력(여기서는 시간)이 적을수록 더 많은 가치를 창출할 수 있는것이 아닌가?

먼저 나는 백엔드 엔지니어로서 백엔드 애플리케이션을 개발하고 있다. 이때 문제 해결을 위한 프로그래밍의 결과의 가치를 `10` 이라고 가정을 해보자. 이 프로그램을 만들기 위해 나는 `2 시간을 소요`했다. 그러면 나의 생산성은 `5` 가 된다. 하지만 나의 동료는 이 문제 해결을 위해 `4시간을 소요` 했다고 가정하자. 이 때 동료의 생산성은 `2.5` 가 된다. 

- 여기서 생산성은 수치가 높을수록 좋은 생산성을 갖고 있다

> 나 : 10 / 2 = 5
> 동료 : 10 / 4 = 2.5

이렇게 수치상으로 보면 내가 동료 직원보다 생산성이 높아 보인다. 하지만 여기에는 여러가지 함정이 존재하고 있지만 대표적으로 언어의 선택이다.

예를 들어 이 문제는 HTTP API 를 제공해야 한다고 해보자. 이 때 나는 Spring 을 이용해 프로그래밍을 하였고, 동료는 C 언어를 이용해서 개발했다고 가정해보자. 

Spring 은 웹 (도는 HTTP 프로토콜 기반 API) 개발에 최적화된 프레임워크인 반면 C 언어는 HTTP 통신을 위한 소켓 연결 부터 프로토콜 규격에 맞는 데이터 스트럭처 등을 하나하나 구현해야 하므로 더욱 많은 시간이 소요될 것이다.  

또 어떠한 알고리즘은 Python 을 이용하면 아주 간결하고 쉽게 작성할 수 있는 반면 Java 를 이용하면 복잡한 코드 구조를 갖을 수 있다. 

이렇듯 프로그램 구현에 필요한 언어의 선택은 내가 투자할 수 있는 시간 (노력)을 줄여줄 수 있다. 하지만 모든 소프트웨어 엔지니어가 모든 언어에 통달한것은 아니며, 자신의 주력언어를 이용해 현재 우리 팀에 존재하는 문제를 해결하기 위해 적절한 위치에서 프로그래밍을 하고 있을 뿐이다. 

그렇다고 해서 시간이 생산성에 영향을 미치지 않는것은 아니다. 절대적인 기준이 될 수 없다고 말하는 것 뿐이다. 내가 프로그래밍을 하는데 있어 시간이 줄어든다면 하나의 가치뿐 아니라 둘, 셋 이상의 가치를 만들어 낼 수있기 때문이다.  

## 품질 또한 생산성에 중요한 요소 중 하나이다

JAVA 를 이용한 뉴스피드 검색을 위한 애플리케이션을 철수와 영희가 개발을 각각 진행했다고 하고 아래 코드를 보자.

```java
/**
* @author  철수
*/

class NewsFeed {
	String title;
	String content;
}

class NewsFeedApplication {
	List<NewsFeed> getNewsFeed(String platform) {
		if ("Google".equals(platform)) {
			// Google news feed 조회
		} else if ("Naver".equals(platform)) {
			// Naver news feed 조회
		} else {
			// 어딘가 news feed 조회
		}
 	}
}
```

```java

/**
* @author  영희
*/

class NewsFeed {
	String title;
	String content;
}

interface NewsFeedApplication {
	List<NewsFeed> getNewsFeed();
}

class GoogleNewFeedApplication implements NewsFeedApplication {
	@Override
	public List<NewsFeed> getNewsFeed() {
		// Google news feed 조회
	}
}

class NaverNewFeedApplication implements NewsFeedApplication {
	@Override
	public List<NewsFeed> getNewsFeed() {
		// Naver news feed 조회
	}
}

class YTNNewFeedApplication implements NewsFeedApplication {
	@Override
	public List<NewsFeed> getNewsFeed() {
		// YTN news feed 조회
	}
}
```

위 코드중 영희와 철수중 누가 코드의 품질이 더 좋다고 말할 수 있을까. 단연코 영희일 것이다. `NewsFeedApplication` 을 추상화 함으로서 플랫폼이 추가되어도 유지보수가 용이한 코드가 나올 것이다. 물론 객체를 잘 추상화하고, 역할별로 잘 분리하는 것 만이 아닌 `런타임 에러` 같은 것 또한 예외처리를 잘 해놓은 것이 품질에 좋은 영향을 줄 것이다.

사실 이러한 코드 품질은 나의 생산성을 끌어 올리는 것 뿐만이 아니라 다른 누군가가 나의 코드를 분석하고 유지보수 하기 쉽도록 해주는 결과를 가져올 수 도 있다. 

> 오해하지 말아야 할 것이 리팩토링을 잘 해 놓은 것이 무조건 코드를 분석하기  쉽다는 것은 아니다. 디자인패턴을 적용하다 보면 코드 분석이 어려운 경우도 존재하기 때문이다. 

### 잠깐

이전에 읽은 `소프트웨어 장인정신 이야기` 에서는 이런 말이 있다. 

>  **QA 가 테스트를 하도록 하지 말아라.**

이는 가능하면 테스트는 개발단계에서 완료 하라는 의미이다. 그러면서 `TDD` 에 대한 중요성에 대해 약 6장 정도에 걸처 중요성에 대해 말해주고 하는법에 대해 설명해 준다. 
결국 `TDD` 는 위에서 말한 `런타임 에러`를 사전에 방지할 수 있으며, 코드의 리팩토링 또한 테스트 결과에 영향을 주지 않으면서 더 좋은 코드 품질로 나아갈 수 있도록 도움을 준다.  그리고 QA 는 코드의 품질 보다는 기능의 품질을 우선시하여 사용자에게 더 나은 서비스를 제공하기 위한 방법을 모색할 수 있도록 해야한다는 것이다.

## 결론 & 느낀점

결국 생산성은 시간, 품질, 가치 외에도 여러가지 복잡한 요인들로 구성되어 있다. 이러한 생산성을 단지 시간이 적게 걸렸다는 이유로, 단순히 품질이 높다는 이유로 생산성이 높다고 표현하기에는 모호한 부분이 많이 있다는것을 알았다. 

나 또한 업무를 하다 보면 빨리 만들고, 잘 만들면 생산성 높은 개발자라고 생각했었지만 1장을 읽으며 생각보다 내가 가지고 있는 생산성에 대한 가치관은 개선되어야 할 부분이 많다는 것얼 알게 되었다. 아직은 1장밖에 읽지 않아서 잘 모르겠지만 이 책을 다 읽을때에는 생산성을 측정하는 방법과 나의 생산성은 어느정도인지 추정할 수 있었으면 좋겠다.

이 말고도 많은 이야기가 나왔지만 1장은 이정도만 하고 넘어가자. 