
`1장 생산성이 10배 이상이라고 알려진 전설의 프로그래머`
`2장 한 가지 지표로는 생산성을 측정할 수 없다`
`3장 생산성을 측정해서는 안되는 이유`

1, 2, 3장의 내용을 토대로 내가 느끼는 생산성이라는 것에 대해 정리해 보았다.

## 생산성이란

본격적으로 정리하기 전에 먼저 생산성은 어떤 것이  한 번 알아보자.

1장을 읽다 보면 생산성을 나타내는 기준에 대해 이야기 하는데 이렇게 표현한다.

> 생산성은 노력 대비 가치이다.

풀어서 생각해보면 가치를 만들어냄에 있어 투자한 노력을 생산성이라 표현하게 되며 생산성과 노력은 반비례 관계에 있다고 할 수 있다. 즉, `생산성`, `노력`, `가치` 는 아래처럼 표기할 수도 있을 것 같다.

> 생산성 = 가치 / 노력

## 시간은 생산성의 기준이 될 수 없다

여기서 이런 의문이 들 수 있다. 

> 1. 생산성은 왜 노력에 반비례 하는 것인가?
> 2. 노력(시간)이 적을수록 더 많은 가치를 창출할 수 있는 것 아닌가?

먼저 나는 백엔드 엔지니어로서 백엔드 애플리케이션을 개발하고 있다. 이때 문제 해결을 위한 프로그래밍의 결과의 가치를 `10` 이라고 가정을 해보자. 이 프로그램을 만들기 위해 나는 `2 시간을 소요`했다. 그러면 나의 생산성은 `5` 가 된다. 하지만 나의 동료는 이 문제 해결을 위해 `4시간을 소요` 했다고 가정하자. 이 때 동료의 생산성은 `2.5` 가 된다. 

- 여기서 생산성은 수치가 높을수록 좋은 생산성을 갖고 있다

> 나 : 10 / 2 = 5
> 동료 : 10 / 4 = 2.5

이렇게 수치 상으로 보면 내가 동료 직원보다 생산성이 높아 보인다. 하지만 여기에는 여러가지 함정이 존재하고 있지만 대표적으로 언어의 선택이다.

예를 들어 이 문제는 HTTP API 제공해야 한다고 해보자. 이 때 나는 `Spring Framework`를 이용해 프로그래밍을 하였고, 동료는 C 언어를 이용해서 개발했다고 가정해보자. 

Spring 은 웹 (도는 HTTP 프로토콜 기반 API) 개발에 최적화된 `Framework`이며, 반면 C 언어는 HTTP 통신을 위한 소켓 연결부터 프로토콜 규격에 맞는 자료구조 등을 하나하나 구현해야 하므로 더욱 많은 시간이 소요될 것이다. 

또 어떠한 알고리즘은 `Python`을 이용하면 아주 간결하고 쉽게 작성할 수 있는 반면 Java 를 이용하면 복잡한 코드 구조를 갖을 수 있다. 

이렇듯 프로그램 구현에 필요한 언어의 선택은 내가 투자할 수 있는 노력(시간)을 줄여줄 수 있다. 하지만 모든 소프트웨어 엔지니어가 모든 언어에 통달한 것은 아니며, 자신의 주력 언어를 이용해 현재 우리 팀에 존재하는 문제를 해결하기 위해 적절한 위치에서 프로그래밍을 하고 있을 뿐이다. 

그렇다고 해서 시간이 생산성에 영향을 미치지 않는 것은 아니다. 절대적인 기준이 될 수 없다고 말하는 것 뿐이다. 내가 프로그래밍을 하는데 있어 시간이 줄어든다면 하나의 가치 뿐 아니라 둘, 셋 이상의 가치를 만들어 낼 수 있기 때문이다.  

## 품질 또한 생산성에 중요한 요소 중 하나이다

JAVA 를 이용한 뉴스피드 검색을 위한 애플리케이션을 철수와 영희가 개발을 각각 진행했다고 하고 아래 코드를 보자.

```java
/**
* @author  철수
*/

class NewsFeed {
	String title;
	String content;
}

class NewsFeedApplication {
	List<NewsFeed> getNewsFeed(String platform) {
		if ("Google".equals(platform)) {
			// Google news feed 조회
		} else if ("Naver".equals(platform)) {
			// Naver news feed 조회
		} else {
			// 어딘가 news feed 조회
		}
 	}
}
```

```java

/**
* @author  영희
*/

class NewsFeed {
	String title;
	String content;
}

interface NewsFeedApplication {
	List<NewsFeed> getNewsFeed();
}

class GoogleNewFeedApplication implements NewsFeedApplication {
	@Override
	public List<NewsFeed> getNewsFeed() {
		// Google news feed 조회
	}
}

class NaverNewFeedApplication implements NewsFeedApplication {
	@Override
	public List<NewsFeed> getNewsFeed() {
		// Naver news feed 조회
	}
}

class YTNNewFeedApplication implements NewsFeedApplication {
	@Override
	public List<NewsFeed> getNewsFeed() {
		// YTN news feed 조회
	}
}
```

위 코드중 영희와 철수중 누가 코드의 품질이 더 좋다고 말할 수 있을까. 단연코 영희일 것이다. `NewsFeedApplication` 을 추상화 함으로서 플랫폼이 추가되어도 유지보수가 용이한 코드가 나올 것이다. 물론 객체를 잘 추상화하고, 역할별로 잘 분리하는 것 만이 아닌 `런타임 에러` 같은 것 또한 예외처리를 잘 해놓은 것이 품질에 좋은 영향을 줄 것이다.

사실 이러한 코드 품질은 나의 생산성을 끌어 올리는 것 뿐만이 아니라 다른 누군가가 나의 코드를 분석하고 유지보수 하기 쉽도록 해주는 결과를 가져올 수 도 있다. 

> 오해하지 말아야 할 것이 리팩토링을 잘 해 놓은 것이 무조건 코드를 분석하기  쉽다는 것은 아니다. 디자인패턴을 적용하다 보면 코드 분석이 어려운 경우도 존재하기 때문이다. 

### 잠깐

이전에 읽은 `소프트웨어 장인정신 이야기` 에서는 이런 말이 있다. 

>  **QA 가 테스트를 하도록 하지 말아라.**

이는 가능하면 테스트는 개발단계에서 완료 하라는 의미이다. 그러면서 `TDD` 에 대한 중요성에 대해 약 6장 정도에 걸처 중요성에 대해 말해주고 하는법에 대해 설명해 준다. 
결국 `TDD` 는 위에서 말한 `런타임 에러`를 사전에 방지할 수 있으며, 코드의 리팩토링 또한 테스트 결과에 영향을 주지 않으면서 더 좋은 코드 품질로 나아갈 수 있도록 도움을 준다.  그리고 QA 는 코드의 품질 보다는 기능의 품질을 우선시하여 사용자에게 더 나은 서비스를 제공하기 위한 방법을 모색할 수 있도록 해야한다는 것이다.

## 결론

결국 생산성은 시간, 품질, 가치 외에도 여러가지 복잡한 요인들로 구성되어 있다. 이러한 생산성을 단지 시간이 적게 걸렸다는 이유로, 단순히 품질이 높다는 이유로 생산성이 높다고 표현하기에는 모호한 부분이 많이 있다.

마지막으로 정리 책에 나온 핵심 내용 정리 한 번 하고 넘어가자.

### 1장 생산성이 10배 이상이라고 알려진 전설의 프로그래머

- 생산성이 낮아지려면 한없이 낮아질 수 있다.
- 개발 속도 뿐 아니라 프로그램의 질도 중요하다. 
- 중요한 사안은 최고의 프로그래머에게 맡겨라
- 터무니없이 생산성이 낮은 프로그래머가 팀에 합류하지 않도록 최선을 다하라

### 2장 한 가지 지표로는 생산성을 측정할 수 없다

> 코드를 몇 줄 작성했는지로 소프트웨어의 생산성을 측정하는 것은 비행기의 무게로 비행기에 대한 진척 정도를 측정하는 것과 같다 - 빌 게이츠

> 소프트웨어 엔지니어링의 목적은 복잡함을 통제하는 것이지 복잡함을 만들어 내는 것이 아니다. - 파멜라 제이브

- 소프트웨어 엔지니어를 측정하기 위한 단일 생산성 지표는 존재하지 않는다.
- 대신에 특정 질문에 맞춤화된 지표 집합에 집중하라.

### 3장 생산성을 측정해서는 안되는 이유

- 생산성을 개선하려면 생산성에 영향을 미치는 요소를 설명할 수 있어야 한다.
- 팀은 항상 변화하기 때문에 자료를 통해 팀 해 팀 행동 방식에 관한 통찰을 얻는 것은 매우 어렵다.
- 관리자는 팀과 상호 작용함으로써 이러한 정성적인 통찰을 얻는 것을 목표로 해야한다.