
`1장 생산성이 10배 이상이라고 알려진 전설의 프로그래머`
`2장 한 가지 지표로는 생산성을 측정할 수 없다`
`3장 생산성을 측정해서는 안되는 이유`

1, 2, 3장의 내용을 토대로 내가 느끼는 생산성이라는 것에 대해 정리해 보았다.

## 생산성이란

본격적으로 정리하기 전에 먼저 생산성은 어떤 것이  한 번 알아보자.

1장을 읽다 보면 생산성을 나타내는 기준에 대해 이야기 하는데 이렇게 표현한다.

> 생산성은 노력 대비 가치이다.

풀어서 생각해보면 가치를 만들어냄에 있어 투자한 노력을 생산성이라 표현하게 되며 생산성과 노력은 반비례 관계에 있다고 할 수 있다. 즉, `생산성`, `노력`, `가치` 는 아래처럼 표기할 수도 있을 것 같다.

> 생산성 = 가치 / 노력

## 시간은 생산성의 기준이 될 수 없다

여기서 이런 의문이 들 수 있다. 

> 1. 생산성은 왜 노력에 반비례 하는 것인가?
> 2. 노력(시간)이 적을수록 더 많은 가치를 창출할 수 있는 것 아닌가?

먼저 나는 백엔드 엔지니어로서 백엔드 애플리케이션을 개발하고 있다. 이때 문제 해결을 위한 프로그래밍의 결과의 가치를 `10` 이라고 가정을 해보자. 이 프로그램을 만들기 위해 나는 `2 시간을 소요`했다. 그러면 나의 생산성은 `5` 가 된다. 하지만 나의 동료는 이 문제 해결을 위해 `4시간을 소요` 했다고 가정하자. 이 때 동료의 생산성은 `2.5` 가 된다. 

- 여기서 생산성은 수치가 높을수록 좋은 생산성을 갖고 있다

> 나 : 10 / 2 = 5
> 동료 : 10 / 4 = 2.5

이렇게 수치 상으로 보면 내가 동료 직원보다 생산성이 높아 보인다. 하지만 여기에는 여러가지 함정이 존재하고 있지만 대표적으로 언어의 선택이다.

예를 들어 이 문제는 HTTP API 제공해야 한다고 해보자. 이 때 나는 `Spring Framework`를 이용해 프로그래밍을 하였고, 동료는 C 언어를 이용해서 개발했다고 가정해보자. 

Spring 은 웹 (도는 HTTP 프로토콜 기반 API) 개발에 최적화된 `Framework`이며, 반면 C 언어는 HTTP 통신을 위한 소켓 연결부터 프로토콜 규격에 맞는 자료구조 등을 하나하나 구현해야 하므로 더욱 많은 시간이 소요될 것이다. 

또 어떠한 알고리즘은 `Python`을 이용하면 아주 간결하고 쉽게 작성할 수 있는 반면 Java 를 이용하면 복잡한 코드 구조를 갖을 수 있다. 

이렇듯 프로그램 구현에 필요한 언어의 선택은 내가 투자할 수 있는 노력(시간)을 줄여줄 수 있다. 하지만 모든 소프트웨어 엔지니어가 모든 언어에 통달한 것은 아니며, 자신의 주력 언어를 이용해 현재 우리 팀에 존재하는 문제를 해결하기 위해 적절한 위치에서 프로그래밍을 하고 있을 뿐이다. 

그렇다고 해서 시간이 생산성에 영향을 미치지 않는 것은 아니다. 절대적인 기준이 될 수 없다고 말하는 것 뿐이다. 내가 프로그래밍을 하는데 있어 시간이 줄어든다면 하나의 가치 뿐 아니라 둘, 셋 이상의 가치를 만들어 낼 수 있기 때문이다.  

## 품질 또한 생산성에 중요한 요소 중 하나이다

JAVA 를 이용한 뉴스피드 검색을 위한 애플리케이션을 철수와 영희가 개발을 각각 진행했다고 하고 아래 코드를 보자.

```java
/**
* @author  철수
*/

class NewsFeed {
	String title;
	String content;
}

class NewsFeedApplication {
	List<NewsFeed> getNewsFeed(String platform) {
		if ("Google".equals(platform)) {
			// Google news feed 조회
		} else if ("Naver".equals(platform)) {
			// Naver news feed 조회
		} else {
			// 어딘가 news feed 조회
		}
 	}
}
```

```java

/**
* @author  영희
*/

class NewsFeed {
	String title;
	String content;
}

interface NewsFeedApplication {
	List<NewsFeed> getNewsFeed();
}

class GoogleNewFeedApplication implements NewsFeedApplication {
	@Override
	public List<NewsFeed> getNewsFeed() {
		// Google news feed 조회
	}
}

class NaverNewFeedApplication implements NewsFeedApplication {
	@Override
	public List<NewsFeed> getNewsFeed() {
		// Naver news feed 조회
	}
}

class YTNNewFeedApplication implements NewsFeedApplication {
	@Override
	public List<NewsFeed> getNewsFeed() {
		// YTN news feed 조회
	}
}
```

위 코드중 영희와 철수중 누가 코드의 품질이 더 좋다고 말할 수 있을까. 단연코 영희일 것이다. `NewsFeedApplication` 을 추상화 함으로서 플랫폼이 추가되어도 유지보수가 용이한 코드가 나올 것이다. 물론 객체를 잘 추상화하고, 역할별로 잘 분리하는 것 만이 아닌 `런타임 에러` 같은 것 또한 예외처리를 잘 해놓은 것이 품질에 좋은 영향을 줄 것이다.

사실 이러한 코드 품질은 나의 생산성을 끌어 올리는 것 뿐만이 아니라 다른 누군가가 나의 코드를 분석하고 유지보수 하기 쉽도록 해주는 결과를 가져올 수 도 있다. 

> 오해하지 말아야 할 것이 리팩토링을 잘 해 놓은 것이 무조건 코드를 분석하기  쉽다는 것은 아니다. 디자인패턴을 적용하다 보면 코드 분석이 어려운 경우도 존재하기 때문이다. 
### 잠깐

이전에 읽은 `소프트웨어 장인정신 이야기` 에서는 이런 말이 있다. 

>  **QA 가 테스트를 하도록 하지 말아라.**

이는 가능하면 테스트는 개발단계에서 완료 하라는 의미이다. 그러면서 `TDD` 에 대한 중요성에 대해 약 6장 정도에 걸처 중요성에 대해 말해주고 하는법에 대해 설명해 준다. 
결국 `TDD` 는 위에서 말한 `런타임 에러`를 사전에 방지할 수 있으며, 코드의 리팩토링 또한 테스트 결과에 영향을 주지 않으면서 더 좋은 코드 품질로 나아갈 수 있도록 도움을 준다.  그리고 QA 는 코드의 품질 보다는 기능의 품질을 우선시하여 사용자에게 더 나은 서비스를 제공하기 위한 방법을 모색할 수 있도록 해야한다는 것이다.

## 시간과 경쟁 

시간으로 생산성을 측정하는 방법으로 잠시 돌아가서 책에 나온 예시를 잠시 보자.

 > `3장 생산성을 측정해서는 안 되는 이유 - 의도치 않은 결과 중(58p)`
 > 시간을 기준으로 생산성을 측정한다고 가정해보자. 프로그램을 개발 할 때  커밋을 빨리 하는 개발자가 많은 팀은 소프트웨어가 더 빨리 출시하게 된다.  하지만 출시 결과(**시장성, 매출 같은 긍정적 결과 또는 소프트웨어가 실패하거나 브랜드에 악영향을 주는 것 같은 부정적 결과**)를 측정하지 않는다면 조직의 긍정적인 목표에 해를 끼칠 수 있다. 
 > 예를 들어 경쟁 때문에 A팀이 출시한 소프트웨어는 출시 시간에 쫓기지 않았더라면 발생하지 않았을 오류를 더 많이 포함하고 있거나 당장에 쉬운 해결 방법을 선택함으로써 장기적으로 재작업 해야 할 가능성을 더 크게 내포하고 있을 수 있다.
 
 이 문장을 보면서 최근 진행하던 프로젝트가 생각이 났다. 물론 나의 개발 실력도 좋지 않았을 뿐 아니라, 한 달이라는 시간 동안 프로젝트의 50% 정도의 코드를 변경(요구 사항 분석, 설계, 개발, 신규 기능 추가) 해야 했기 때문이다. 개발을 진행하면서 처음 들어왔던 요구 사항과 별개로 매 주 2~3 가지 이상의 요구 사항을 추가로 개발해야 했고, 생전 처음 보는 오픈소스 솔루션을 분석하여 사용 방법과 API 연동을 하는 작업을 해야 했다. 

이러한 개발일정동안 코드를 조금씩 개선해서 구조면에서는 큰 문제가 없었지만, 중간에 추가되는 요구사항 같은 경우에 대응하지 못하도록 만든 코드들이 눈에 많이 띄게 되어 스파게티 코드가 되가는 것을 볼 수 밖에 없었다. (변명으로 들리겠지만 시간이 너무 부족하였다.)

눈물을 머금고 매일 아침 9시 출근 밤 11시 퇴근에 주말 출근까지 하며 결과적으로 완성을 하였지만, 클라이언트에게 보여주기 전 주말 문제가 발생했다. 오픈소스를 이용한 솔루션의 인프라 구성과 접근제한에 대한 이슈와 수많은 버그들이었다. (사실 인프라 구성은 큰 문제가 되지 않는다)

이 버그들을 보면 사소한 실수에서 발생하는 버그들이(npe 예외 처리, 문자열 길이 제한 문제) 대부분이었다. 

> **변명** : 이런 경우 TDD 를 적용하면 이런 일이 발생하지 않을 것이라고 할 수 있다. 하지만 TDD 는 많은 경험이 있어야 사용 가능 할 것 같다. TDD 개발 시 중요한 점은 사전에 발생할 수 있는 예외를 처리하고 넘어가야 하는 것인데 개발 경험이 풍부하지 않은 이상 수많은 예외를 고려할 수 없다. 또한 아직 Test Framework 에 대한 경험이 부족하다 보니 테스트 코드를 작성하더라도 정상 동작하지 않는 경우가 발생해 주석 처리하고 넘어가기도 했다. 
> 하지만 TDD 는 2024년에 적용하면서 개발 할 목표를 갖고 있다. 

이런 경험은 나만이 아닌 대부분의 프로그래머가 한 번 이상 있었을 것이라고 생각된다. 
## 결론

결국 생산성은 시간, 품질, 가치 외에도 여러가지 복잡한 요인들로 구성되어 있다. 이러한 생산성을 단지 시간이 적게 걸렸다는 이유로, 단순히 품질이 높다는 이유로 생산성이 높다고 표현하기에는 모호한 부분이 많이 있다.

이 책에서는 생산성을 측정하는 것은 인센티브를 왜곡시킬 수 있고 하며,  특히 생산성을 제대로 측정하지 못한 경우 더욱 그러하다고 한다. 또한, 생산성 측정치로부터 어설픈 추론을 함으로써 오히려 좋지 않은 운영결정을 내릴 수 있다고 한다.

> 여기서 인센티브는 아래의 의미이다.
> - 장려책 또는 어떠한 일에 동기를 부여하게 하는 것

마지막으로 정리 책에 나온 핵심 내용 정리 한 번 하고 넘어가자.

### 1장 생산성이 10배 이상이라고 알려진 전설의 프로그래머

- 생산성이 낮아지려면 한없이 낮아질 수 있다.
- 개발 속도 뿐 아니라 프로그램의 질도 중요하다. 
- 중요한 사안은 최고의 프로그래머에게 맡겨라
- 터무니없이 생산성이 낮은 프로그래머가 팀에 합류하지 않도록 최선을 다하라

### 2장 한 가지 지표로는 생산성을 측정할 수 없다

> 코드를 몇 줄 작성했는지로 소프트웨어의 생산성을 측정하는 것은 비행기의 무게로 비행기에 대한 진척 정도를 측정하는 것과 같다 - 빌 게이츠

> 소프트웨어 엔지니어링의 목적은 복잡함을 통제하는 것이지 복잡함을 만들어 내는 것이 아니다. - 파멜라 제이브

- 소프트웨어 엔지니어를 측정하기 위한 단일 생산성 지표는 존재하지 않는다.
- 대신에 특정 질문에 맞춤화된 지표 집합에 집중하라.

### 3장 생산성을 측정해서는 안되는 이유

- 생산성을 개선하려면 생산성에 영향을 미치는 요소를 설명할 수 있어야 한다.
- 팀은 항상 변화하기 때문에 자료를 통해 팀 해 팀 행동 방식에 관한 통찰을 얻는 것은 매우 어렵다.
- 관리자는 팀과 상호 작용함으로써 이러한 정성적인 통찰을 얻는 것을 목표로 해야한다.

